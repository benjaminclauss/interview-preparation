<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Sorting & Searching - Interview Preparation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Sorting & Searching";
    var mkdocs_page_input_path = "sorting-and-searching.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Interview Preparation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../big-o.md">Big O</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../arrays-and-strings/">Arrays & Strings</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../linked-lists/">Linked Lists</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../stacks/">Stacks</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../queues/">Queues</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../trees/">Trees</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../heaps/">Heaps</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../tries/">Tries (Prefix Trees)</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../graphs/">Graphs</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../bit-manipulation/">Bit Manipulation</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Sorting & Searching</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#sorting-algorithms">Sorting Algorithms</a></li>
    

    <li class="toctree-l2"><a href="#searching-algorithms">Searching Algorithms</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../recursion-and-dynamic-programming/">Recursion & Dynamic Programming</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../backtracing/">Backtracing</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../scheduling.md">Scheduling</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../divide-and-conquer.md">Divide and Conquer</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../recursion.md">Recursion</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../about/">Example Page</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Other</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../ood/">Object-Oriented Design</a>
                </li>
                <li class="">
                    
    <a class="" href="../c-and-cpp/">C & C++</a>
                </li>
                <li class="">
                    
    <a class="" href="../databases.md">Databases</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Interview Preparation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Sorting & Searching</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="sorting-algorithms">Sorting Algorithms</h2>
<p>Of the five algorithms explained below, Merge Sort, Quick Sort and Bucket Sort are the most commonly used in interviews.</p>
<p><strong>Bubble Sort | Runtime: <code>O(n^2)</code> average and worst case. Memory: <code>O(1)</code>.</strong></p>
<p>In bubble sort, we start at the beginning of the array and swap the first two elements if the first is greater than the second. Then, we go to the next pair, and so on, continuously making sweeps of the array until it is sorted. In doing so, the smaller items slowly "bubble" up to the beginning of the list.</p>
<p><strong>Selection Sort | Runtime: <code>O(n^2)</code> average and worst case. Memory: <code>O(1)</code>.</strong> </p>
<p>Selection sort is the child's algorithm: simple, but inefficient. Find the smallest element using a linear scan and move it to the front (swapping it with the front element). Then, find the second smallest and move it, again doing a linear scan. Continue doing this until all the elements are in place.</p>
<p><strong>Merge Sort | Runtime: <code>O(n log(n))</code> average and worst case. Memory: <code>Depends</code>.</strong></p>
<p>Merge sort divides the array in half, sorts each of those halves, and then merges them back together. Each of those halves has the same sorting algorithm applied to it. Eventually, you are merging just two single­ element arrays. It is the "merge" part that does all the heavy lifting.</p>
<pre><code>TODO
</code></pre>
<p>The space complexity of merge sort is O(n) due to the auxiliary space used to merge parts of the array.</p>
<p><strong>Quick Sort | Runtime: <code>O(n log(n))</code> average, <code>O(n^2)</code> worst case. Memory: <code>O(log(n))</code>.</strong></p>
<p>In quick sort we pick a random element and partition the array, such that all numbers that are less than the partitioning element come before all elements that are greater than it. The partitioning can be performed efficiently through a series of swaps (see below).</p>
<p>If we repeatedly partition the array (and its sub-arrays) around an element, the array will eventually become sorted. However, as the partitioned element is not guaranteed to be the median (or anywhere near the median), our sorting could be very slow. This is the reason for the <code>O(n^2)</code> worst case runtime.</p>
<pre><code>TODO
</code></pre>
<p><strong>Radix Sort | Runtime: <code>O(kn)</code></strong></p>
<p>Radix sort is a sorting algorithm for integers (and some other data types) that takes advantage of the fact that integers have a finite number of bits. In radix sort, we iterate through each digit of the number, grouping numbers by each digit. For example, if we have an array of integers, we might first sort by the first digit, so that the Os are grouped together. Then, we sort each of these groupings by the next digit. We repeat this process sorting by each subsequent digit, until finally the whole array is sorted.</p>
<p>Unlike comparison sorting algorithms, which cannot perform better than <code>O(n log(n))</code> in the average case, radix sort has a runtime of <code>O(kn)</code>, where <code>n</code> is the number of elements and <code>k</code> is the number of passes of the sorting algorithm.</p>
<p><strong>Python Sorting</strong></p>
<pre><code>sorted(list, key=lambda item: get_key_for_item(item), reverse=True)
# reverse is False by default
</code></pre>
<h2 id="searching-algorithms">Searching Algorithms</h2>
<p>In binary search, we look for an element <code>x</code> in a sorted array by first comparing <code>x</code> to the midpoint of the array. If <code>x</code> is less than the midpoint, then we search the left half of the array. If <code>x</code> is greater than the midpoint, then we search the right half of the array. We then repeat this process, treating the left and right halves as subar­rays. Again, we compare <code>x</code> to the midpoint of this subarray and then search either its left or right side. We repeat this process until we either find <code>x</code> or the subarray has size <code>0</code>.</p>
<p>Note that although the concept is fairly simple, getting all the details right is far more difficult than you might think. As you study the code below, pay attention to the plus ones and minus ones.</p>
<pre><code>def binary_search(array, target):
    left, right = 0, len(array) - 1
    while left &lt;= right:
        middle = (left + right) // 2
        if array[middle] == target:
            return middle
        if target &lt; array[middle]:
            right = middle - 1
        else:
            left = middle + 1
    return -1
</code></pre>
<p>Potential ways to search a data structure extend beyond binary search, and you would do best not to limit yourself to just this option. You might, for example, search for a node by leveraging a binary tree, or by using a hash table. Think beyond binary search!</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../recursion-and-dynamic-programming/" class="btn btn-neutral float-right" title="Recursion & Dynamic Programming">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../bit-manipulation/" class="btn btn-neutral" title="Bit Manipulation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../bit-manipulation/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../recursion-and-dynamic-programming/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
